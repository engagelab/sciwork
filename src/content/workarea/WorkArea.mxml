<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx" xmlns:materials="content.workarea.materials.*" xmlns:preview="content.workarea.preview.*" xmlns:workarea="content.workarea.*" creationComplete="initWorkArea(event)" xmlns:selection="content.workarea.selection.*">
	
	<fx:Script>
		<![CDATA[
			import com.adobe.serialization.json.JSON;
			
			import content.workarea.materials.MaterialsItem;
			
			import listeners.MaterialToPreviewEvent;
			import listeners.SelectMaterialEvent;
			import listeners.SubmitKeywordsEvent;
			
			import mx.controls.Alert;
			import mx.events.FlexEvent;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			
			import spark.events.TextOperationEvent;
			
			public static const VIDEO_TYPE:String = "VIDEO_TYPE";
			public static const IMAGE_TYPE:String = "IMAGE_TYPE";
			public static const TEXT_TYPE:String = "TEXT_TYPE";
			
			[Bindable] private var _enableMaterials:Boolean = false;
			private var _isKeywordUpdate:Boolean = false;
			
			/**
			 * 
			 * Event handling method for creationComplete
			 * 
			 **/
			protected function initWorkArea(event:FlexEvent):void {
				this.addEventListener(resourceManager.getString('resources', 'MATERIAL_TO_PREVIEW'), handleMaterialRequest);
				this.addEventListener(resourceManager.getString('resources', 'KEYWORD_LIST_SUBMITTED'), handleKeywordsSubmitted);
				this.addEventListener(resourceManager.getString('resources', 'EDIT_KEYWORD_LIST'), handleEditKeywords);
				this.addEventListener(resourceManager.getString('resources', 'VIDEO_PLAYER_READY'), handleVideoPlayerReady);
				this.addEventListener(resourceManager.getString('resources', 'ADD_MATERIAL_TO_PORTFOLIO'), handleAddMaterialToPortfolio);
			}
			
			/**
			 * 
			 * Event handling method for ADD_MATERIAL_TO_PORTFOLIO
			 * 
			 **/
			protected function handleAddMaterialToPortfolio(evt:SelectMaterialEvent):void {
				//prepare the JSON object to be sent
				var params:Object = new Object();
				params.id = evt.materialItem.id;
				params.state = evt.addToPortolio;
				
				//create urlrequest with correct headers
				var urlRequest:URLRequest = new URLRequest(resourceManager.getString('resources', 'SERVER_URL') + "/contributions");
				urlRequest.method = URLRequestMethod.PUT;
				urlRequest.contentType = "application/json";
				urlRequest.data = com.adobe.serialization.json.JSON.encode(params);
				
				//load the url and define listeners
				var uploader:URLLoader = new URLLoader();
				uploader.addEventListener(Event.COMPLETE, handleSelectMaterialComplete);
				uploader.addEventListener(IOErrorEvent.IO_ERROR, handleSelectMaterialIOerror);
				uploader.load(urlRequest);
				
			}
			
			/**
			 * 
			 * Event handling method handlePostKeywordsComplete
			 * 
			 **/
			protected function handleSelectMaterialComplete(ev:Event):void {
				//extract result as JSON
				var res:Object = com.adobe.serialization.json.JSON.decode(String(ev.target.data));
				if(res.status == 200) {
					updateCurrentState("assets");
				}
			}
			
			/**
			 * 
			 * Event handling method handlePostKeywordsIOerror
			 * 
			 **/
			protected function handleSelectMaterialIOerror(ev:IOErrorEvent):void {
				Alert.show("An error occured while adding the item to the portfolio.", "Contributions service error");
			}
			
			/**
			 * 
			 * Event handling method for MATERIAL_TO_PREVIEW
			 * 
			 **/
			protected function handleMaterialRequest(evt:MaterialToPreviewEvent):void {
				preview.previewMaterial(evt.materialItem);
			}
			
			/**
			 * 
			 * Event handling method for KEYWORD_LIST_SUBMITTED
			 * 
			 **/
			protected function handleKeywordsSubmitted(evt:SubmitKeywordsEvent):void {
				//build the object to post
				var params:Object = new Object();
				params.groupId = currentGroup.id;
				params.taskId = taskId;
				params.keywords = evt.keywords;
				
				//create urlrequest with correct headers
				var urlRequest:URLRequest = new URLRequest(resourceManager.getString('resources', 'SERVER_URL') + "/keywords");
				if(_isKeywordUpdate) {
					urlRequest.method = URLRequestMethod.PUT;
				}
				else {
					urlRequest.method = URLRequestMethod.POST;
				}
				urlRequest.contentType = "application/json";
				urlRequest.data = com.adobe.serialization.json.JSON.encode(params);
				
				//load the url and define listeners
				var uploader:URLLoader = new URLLoader();
				uploader.addEventListener(Event.COMPLETE, handlePostKeywordsComplete);
				uploader.addEventListener(IOErrorEvent.IO_ERROR, handlePostKeywordsIOerror);
				uploader.load(urlRequest);
			}
			
			/**
			 * 
			 * Event handling method handlePostKeywordsComplete
			 * 
			 **/
			protected function handlePostKeywordsComplete(ev:Event):void {
				//extract result as JSON
				var res:Object = com.adobe.serialization.json.JSON.decode(String(ev.target.data));
				updateKeywordsList(res.keywords);
			}
			
			/**
			 * 
			 * Event handling method handlePostKeywordsIOerror
			 * 
			 **/
			protected function handlePostKeywordsIOerror(ev:IOErrorEvent):void {
				Alert.show("An error occured while posting the keywords from the server.", "Keyword service error");
			}
			
			
			
			/**
			 * 
			 * Switch layout to correct state based on task type
			 * 
			 **/
			public function updateCurrentState(type:String):void {
				
				
				switch(type) {
					case 'keywords': {
						//set correct state in subsequent components
						this.currentState = "keywords";
						selection.currentState = "keywords";
						preview.currentState = "keywordsState";
						
						//get existing keywords for the current task and group
						getKeywordsPortfolio.url = resourceManager.getString('resources', 'SERVER_URL') + "/keywords/" + currentGroup.id + "/" + taskId;
						getKeywordsPortfolio.send();
						break;
					}
						
					case 'assets': {
						//set correct state in subsequent components
						this.currentState = "assets";
						selection.currentState = "assets";
						preview.currentState = "default";
						
						//get existing assets selection (portfolio) for the current task and group
						getAssetsPortfolio.url = resourceManager.getString('resources', 'SERVER_URL') + "/contributions/" + currentGroup.id + "/" + taskId;
						getAssetsPortfolio.send();
						break;
					}
						
					default: {
						this.currentState = "default";
						selection.currentState = "default";
						preview.currentState = "default";
						break;
					}
				}
			}
			
			/**
			 * 
			 * Error handling method for getKeywords service
			 * 
			 **/
			protected function getKeywords_faultHandler(event:FaultEvent):void {
				Alert.show("An error occured while retrieving the keywords from the server.", "Keyword service error");
			}
			
			/**
			 *
			 * Result handling method for getKeywords service 
			 * 
			 **/
			protected function getKeywords_resultHandler(event:ResultEvent):void {
				//store the returned object as JSON 
				var res:Object = com.adobe.serialization.json.JSON.decode(String(event.result));
				
				if(res.keywords != null) {
					updateKeywordsList(res.keywords);
				}
				else {
					selection.keywordSelection.clearWordList();
				}
			}
			
			/**
			 *
			 * Update UI with keywords list 
			 * 
			 **/
			protected function updateKeywordsList(kWords:Array):void {
				if(kWords.length == 5) {
					//update keywords list
					selection.keywordSelection.addNewWords(kWords);
					
					//reset input field
					keywordInput.wordInput.text = "";
				}
			}
			
			/**
			 * 
			 * Event handling method for EDIT_KEYWORD_LIST
			 * 
			 **/
			protected function handleEditKeywords(evt:Event):void {
				//rebuild the keywords string
				var wordString:String = "";
				for each (var word:Object in selection.keywordSelection.wordArray) {
					wordString = wordString + word + " ";
				}
				
				//clear the selection
				selection.keywordSelection.clearWordList();
				
				//append the keywords in the text input
				keywordInput.wordInput.text = wordString.substr(0, wordString.length-1);
				//enable button again via dispatchevent
				keywordInput.wordInput.dispatchEvent(new TextOperationEvent(TextOperationEvent.CHANGE, true));
				
				_isKeywordUpdate = true;
				
			}
			
			/**
			 * 
			 * Error handling method for getAssets service
			 * 
			 **/
			protected function getAssets_faultHandler(event:FaultEvent):void {
				Alert.show("An error occured while retrieving the assets from the server.", "Assets service error");
			}
			
			/**
			 *
			 * Result handling method for getAssets service 
			 * 
			 **/
			protected function getAssets_resultHandler(event:ResultEvent):void {
				//store the returned object as JSON 
				var contributions:Object = com.adobe.serialization.json.JSON.decode(String(event.result));
				
				//clean current material holders
				materialItems.removeAllElements();
				selection.assetSelection.portfolioGroup.removeAllElements();
				
				//TODO: could try to sort the arrays in a combined one, sorted according to timestamp
				parseMaterialSubArray(contributions.svideos, VIDEO_TYPE);
				parseMaterialSubArray(contributions.simages, IMAGE_TYPE);
				parseMaterialSubArray(contributions.spostits, TEXT_TYPE);
			}
			
			/**
			 *
			 * Parsing method to assign retrieved material to a correct preview item
			 * 
			 **/
			protected function parseMaterialSubArray(subArray:Array, materialType:String):void {
				var newItem:MaterialsItem;
				
				//extract materials
				for each (var material:Object in subArray) {
					newItem = new MaterialsItem();
					
					//add it to the portfolio instead is this is true
					if(material.isPortfolio == "false") {
						materialItems.addElement(newItem);
					}
					else {
						selection.assetSelection.portfolioGroup.addElement(newItem);
					}
					
					//assign id
					newItem.id = material.id;
					
					//pick correct preview type
					switch(materialType) {
						case VIDEO_TYPE:
							newItem.setupPreview(VIDEO_TYPE, material.uri, resourceManager.getString('resources', 'YOUTUBE_BASE_IMAGE_URL')+material.uri+"/1.jpg");
							break;
						case IMAGE_TYPE:
							newItem.setupPreview(IMAGE_TYPE, resourceManager.getString('resources', 'YOUTUBE_BASE_IMAGE_URL')+material.uri+"/0.jpg", resourceManager.getString('resources', 'YOUTUBE_BASE_IMAGE_URL')+material.uri+"/1.jpg");
							break;
						case TEXT_TYPE:
							//todo:
							break;	
					}
					
				}
			}
			
			/**
			 *
			 * Event handling method for VIDEO_PLAYER_READY 
			 * 
			 **/
			protected function handleVideoPlayerReady(evt:Event):void {
				_enableMaterials = true;
			}
			
			
		]]>
	</fx:Script>
	
	<fx:Declarations>
		<s:HTTPService method="GET" result="getKeywords_resultHandler(event)" fault="getKeywords_faultHandler(event)" resultFormat="text" id="getKeywordsPortfolio" />
		<s:HTTPService method="GET" result="getAssets_resultHandler(event)" fault="getAssets_faultHandler(event)" resultFormat="text" id="getAssetsPortfolio" />
		
		<fx:Object id="currentGroup" />
		<fx:String id="taskId" />
	</fx:Declarations>
	
	<s:states>
		<s:State name="default" />
		<s:State name="assets" />
		<s:State name="keywords" />
	</s:states>
	
	<s:HGroup width="100%" height="100%" gap="{sciwork._gapBetweenContainers}">
		<s:VGroup width="100%" height="100%" gap="{sciwork._gapBetweenContainers}">
			<preview:Preview id="preview" width="100%" height="100%" />
			<s:BorderContainer id="materials" width="100%" includeIn="assets" enabled="{_enableMaterials}" borderAlpha=".3" >
				<s:Scroller top="5" right="5" bottom="5" left="5">
					<s:HGroup id="materialItems" />
				</s:Scroller>
			</s:BorderContainer>
			<workarea:KeywordInput id="keywordInput" width="100%" height="50" includeIn="keywords" />
		</s:VGroup>
		<selection:Selection id="selection" width="200" height="100%" />
	</s:HGroup>
</s:Group>
